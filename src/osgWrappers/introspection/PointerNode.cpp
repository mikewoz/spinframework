// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <cppintrospection/ReflectionMacros>
#include <cppintrospection/TypedMethodInfo>
#include <cppintrospection/StaticMethodInfo>
#include <cppintrospection/Attributes>

#include <GroupNode.h>
#include <PointerNode.h>
#include <SceneManager.h>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

BEGIN_OBJECT_REFLECTOR(spin::PointerNode)
	I_DeclaringFile("PointerNode.h");
	I_BaseType(spin::RayNode);
	I_Constructor2(IN, spin::SceneManager *, sceneManager, IN, char *, initID,
	               ____PointerNode__SceneManager_P1__char_P1,
	               "",
	               "");
	I_Method0(void, callbackUpdate,
	          Properties::VIRTUAL,
	          __void__callbackUpdate,
	          "",
	          "For nodes that require regular programmatic control, there is a callback that is evaluated with every refresh. This function can thus be used for animations, or any other periodic updates.Note that changes to the scene graph structure (eg, moving/deleting nodes should NOT be done within this callback because traversals stacks will become corrupted. The technique is rather to enable a flag and then do the actual change in the SceneManager::updateGraph() method. ");
	I_Method1(spin::GroupNode *, getNodeFromIntersections, IN, int, index,
	          Properties::NON_VIRTUAL,
	          __GroupNode_P1__getNodeFromIntersections__int,
	          "",
	          "");
	I_Method1(void, manipulate, IN, int, b,
	          Properties::NON_VIRTUAL,
	          __void__manipulate__int,
	          "",
	          "");
	I_Method0(int, getManipulate,
	          Properties::NON_VIRTUAL,
	          __int__getManipulate,
	          "",
	          "");
	I_Method1(void, setManipulator, IN, const char *, manipulatorType,
	          Properties::VIRTUAL,
	          __void__setManipulator__C5_char_P1,
	          "",
	          "We can call setManipulator and pass the name of a dragger, and the pointer will enable the dragger on the current GroupNode that it is currently pointing at. If the pointer is not intersecting with any node, this will set the dragger on the last manipulated node; this was found to be a desired behaviour instead of constantly ensuring an intersection whenever the user wanted to use a different manipulator. ");
	I_Method1(void, grab, IN, int, b,
	          Properties::NON_VIRTUAL,
	          __void__grab__int,
	          "",
	          "The grab method selects the closest intersected node and temporarily attaches it to the pointer, allowing it to inherit any translation or rotation offsets.Notes: Only nodes derived from GroupNode can be grabbed.If no node is intersected, the grab won't do anything.The node is re-attached to it's original parent when released, so don't delete the parent in the meantime  param b A boolean grab indicator (1 to grab, 0 to release)  ");
	I_Method1(void, slide, IN, float, f,
	          Properties::NON_VIRTUAL,
	          __void__slide__float,
	          "",
	          "Slides the currently grabbed node (if there is one) along the pointer axis (ie, increasing or decreasing the distance). param f The amount by which to slide (positive values slide the attached node AWAY from the pointer  ");
	I_Method1(void, spin, IN, float, f,
	          Properties::NON_VIRTUAL,
	          __void__spin__float,
	          "",
	          "Spins the currently grabbed node (if there is one) around the pointer axis. param f The amount by which to spin (in degrees)  ");
	I_Method0(int, getGrab,
	          Properties::NON_VIRTUAL,
	          __int__getGrab,
	          "",
	          "Whether there is a valid node that is currently 'grabbed'  ");
	I_Method0(std::vector< lo_message >, getState,
	          Properties::VIRTUAL,
	          __std_vectorT1_lo_message___getState,
	          "",
	          "For each subclass of ReferencedNode, we override the getState() method to fill the vector with the correct set of methods for this particular node ");
	I_ProtectedMethod3(void, applyManipulation, IN, osg::Matrix, mat, IN, osg::Vec3, start, IN, osg::Vec3, end,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__applyManipulation__osg_Matrix__osg_Vec3__osg_Vec3,
	                   "",
	                   "Checks intersections for draggers and if so, we apply the drag events ");
	I_ProtectedMethod1(void, applyGrab, IN, osg::Matrix, mat,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__applyGrab__osg_Matrix,
	                   "",
	                   "");
	I_ProtectedMethod0(void, reportIntersections,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__reportIntersections,
	                   "",
	                   "Reports the list of intersected nodes (server-side only) ");
	I_SimpleProperty(int, Grab, 
	                 __int__getGrab, 
	                 0);
	I_SimpleProperty(int, Manipulate, 
	                 __int__getManipulate, 
	                 0);
	I_SimpleProperty(const char *, Manipulator, 
	                 0, 
	                 __void__setManipulator__C5_char_P1);
	I_SimpleProperty(std::vector< lo_message >, State, 
	                 __std_vectorT1_lo_message___getState, 
	                 0);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(spin::PointerNodeActionAdapter)
	I_DeclaringFile("PointerNode.h");
	I_Constructor0(____PointerNodeActionAdapter,
	               "",
	               "");
END_REFLECTOR

